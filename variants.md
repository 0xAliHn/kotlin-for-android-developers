#Variants

This is really one of the most difficult to understand parts. In Java, when we use the generic when there will be problems. The logic tells us that `List<String>` should be able to transition to `List<Object>` because it has weaker restrictions. But let's take a look at this example:

```kotlin
List<String> strList = new ArrayList<>();
List<Object> objList = strList;
objList.add(5);
String str = objList.get(0);
```

If the Java compiler allows us to do so, we can add an `Integer` to` Object` List, but it will obviously crash at some point. This is why the language adds wildcards. Wildcards can increase flexibility in limiting this problem.

If we add `? Extends Object`, we use covariance, which means that we can handle any object that uses a type that is more restrictive than Object, but we are safe if we use` get` The If we want to copy a `Strings` collection into the` Objects` collection, we should be allowed, right?  Then, if we doï¼š

```kotlin
List<String> strList = ...;
List<Object> objList = ...;
objList.addAll(strList);
```

This is possible because the `addAll()` defined in the `Collection` interface is like this:

```java
List<String>
interface Collection<E> ... {
	void addAll(Collection<? extends E> items);
}
```

Otherwise, there is no wildcard, we will not allow the use of `String` List in this method. On the contrary, of course it will fail. We can not use `addAll ()` to add a `Objects` List to` Strings` List. Because we just use that method to get elements from `collection`, which is an example of a perfect covariant (` covariance`).

On the other hand, we can find the inverter (`contravariance`) on the opposite side. According to the example of the collection, if we want to pass the parameters to the collection, we can add more restrictive types to the generic set. For example, we can add `Strings` to` Object`List:

```java
void copyStrings(Collection<? super String> to, Collection<String> from) {
    to.addAll(from);
}
```

The only limitation that adds `Strings` to another collection is that the collection receives` Strings` or parent.

But the wildcard has its limitations. Wildcards define the use of scene variants (`use-site variance`), which means that we need to declare it when we use it. This means that each time we declare a generic variable will increase the template code.

Let's look at an example. Use our previous similar classes:

```java
class TypedClass<T> {
    public T doSomething(){
	    ...
    }
}
```

The code will not be compiled:

```java
TypedClass<String> t1 = new TypedClass<>();
TypedClass<Object> t2 = t1;
```

Although it does not make sense because we still keep all the methods in the class and do not have any damage. We need to specify a type that can have a more flexible definition.

```kotlin
TypedClass<String> t1 = new TypedClass<>();
TypedClass<? extends String> t2 = t1;
```

This makes the code more difficult to understand, and adds some extra template code.

On the other hand, Kotlin can be handled in a much easier way by using the declaration-site variance. This means that when we define a class or interface, we can handle weakly restricted scenes, and we can use it directly elsewhere.

So let's see how it works in Kotlin. Compared to lengthy wildcards, Kotlin uses `out` only for covariance (` covariance`) and uses `in` for the invert (` contravariance`)). In this example, when the objects generated by our class can be saved to weakly constrained variables, we use covariates. We can define the declaration directly in the class {

```kotlin
class TypedClass<out T>() {
    fun doSomething(): T {
	    ...
	}
}
```

That's all we need. Now, in Java can not compile the code in Kotlin can run perfectly:

```kotlin
val t1 = TypedClass<String>()
val t2: TypedClass<Any> = t1
```

If you have used these concepts, I'm sure you can simply use `in` and` out` in Kotlin. Otherwise, you only need some contact and conceptual understanding.
